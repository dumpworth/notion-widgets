<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Custom Progress Bar</title>
  <style>
    /* --- Base Variables --- */
    :root {
      /* Colors */
      --color-progress-zero: #666666;
      --color-progress-0-start: hsl(0, 100%, 20%); --color-progress-0-end: hsl(0, 100%, 20%);
      --color-progress-10-start: hsl(0, 100%, 30%); --color-progress-10-end: hsl(0, 100%, 50%);
      --color-progress-20-start: hsl(0, 100%, 50%); --color-progress-20-end: hsl(30, 100%, 50%);
      --color-progress-30-start: hsl(20, 100%, 50%); --color-progress-30-end: hsl(60, 100%, 50%);
      --color-progress-40-start: hsl(60, 100%, 50%); --color-progress-40-end: hsl(60, 100%, 50%);
      --color-progress-50-start: hsl(60, 100%, 50%); --color-progress-50-end: hsl(90, 100%, 50%);
      --color-progress-60-start: hsl(80, 100%, 50%); --color-progress-60-end: hsl(150, 100%, 50%);
      --color-progress-70-start: hsl(100, 100%, 50%); --color-progress-70-end: hsl(160, 100%, 50%);
      --color-progress-80-start: hsl(150, 100%, 50%); --color-progress-80-end: hsl(180, 100%, 50%);
      --color-progress-90-start: hsl(170, 100%, 50%); --color-progress-90-end: hsl(180, 100%, 70%);
      --color-progress-100-start: var(--color-progress-90-start); --color-progress-100-end: var(--color-progress-90-end);

      /* Class Colors (Start/End) */
      --color-health-start: hsl(150, 100%, 50%); --color-health-end: hsl(180, 100%, 50%);
      --color-magic-start: hsl(220, 100%, 50%); --color-magic-end: hsl(180, 100%, 50%);
      --color-physical-start: hsl(0, 100%, 50%); --color-physical-end: hsl(10, 100%, 70%);
      --color-true-start: hsl(0, 0%, 70%); --color-true-end: hsl(0, 0%, 100%);
      --color-agility-start: hsl(60, 100%, 50%); --color-agility-end: hsl(90, 100%, 50%);
      --color-intelligence-start: cyan; --color-intelligence-end: #ff80ff;
      --color-affinity-start: #ff80ff; --color-affinity-end: #ffb3e7;

      /* Rainbow Gradients */
      --color-rainbow-static: linear-gradient(to right, hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%));
      --color-rainbow-animated: linear-gradient(to right, hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%));

      /* Core Style Variables */
      --progHeight: 10px; --progWidth: 270px;
      --progColor: linear-gradient(to right, #ccc, #999);
      --labelGradient: none;
      --labelColor: var(--color-progress-zero);
      --trackBorderColor: rgba(180, 180, 180, 0.6); --trackShadowColor: rgba(0, 0, 0, 0.1);

      /* --- Animation Variables --- */
      --animation-speed: 3s; /* Default animation duration (can be overridden by JS) */
      --background-width-multiplier: 300%; /* Default multiplier for standard animated gradients */
      /* Removed --current-bg-multiplier */
    }

    /* Removed .progress-container.rainbow override rule */


    /* --- Styles for container, progress, fill, animation, labels --- */
     body { margin: 0; background: transparent; font-family: sans-serif; display: flex; align-items: center; justify-content: center; min-height: 30px; padding: 5px; }
     .wrapper { display: flex; align-items: center; gap: 10px; padding: 0; }
     .progress-container { position: relative; width: var(--progWidth); height: var(--progHeight); border-radius: var(--progHeight); overflow: hidden; border: 1px solid var(--trackBorderColor); background: transparent; box-shadow: inset 0 1px 2px var(--trackShadowColor); box-sizing: border-box; }
     .progress-container[size="infobox"] { width: 207px; } .progress-container[size="ability"] { width: 225px; } .progress-container[size="large"] { width: 540px; }
     progress { display: block; width: 100%; height: 100%; appearance: none; -webkit-appearance: none; border: none; background: transparent; color: transparent; border-radius: 0; }
     progress::-webkit-progress-bar { background: transparent; } progress::-webkit-progress-value { background: transparent; } progress::-moz-progress-bar { background: transparent; }
     .progress-fill-animated { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--progColor); border-radius: 0; transition: width 0.4s ease, background 0.1s linear; }

     /* --- Animation Keyframes & Application --- */
     @keyframes moveGradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

     /* ---- START: MODIFIED CSS (Animation & Size Rules) ---- */
     /* Apply animation timing to both */
     .progress-fill-animated.animated,
     .progress-label.animated-label {
         animation: moveGradient var(--animation-speed) linear infinite; /* Use speed variable */
     }

     /* Apply default background size to both */
     .progress-fill-animated.animated,
     .progress-label.animated-label {
         background-size: var(--background-width-multiplier) 100%; /* Default 300% */
     }

     /* Override background size SPECIFICALLY for RAINBOW animated elements */
     .progress-container.rainbow .progress-fill-animated.animated {
        background-size: 200% 100%; /* Rainbow Fill Override */
     }
     /* Use adjacent sibling selector (+) to target the label next to a rainbow container */
     .progress-container.rainbow + .progress-label.animated-label {
        background-size: 200% 100%; /* Rainbow Label Override */
     }
     /* ---- END: MODIFIED CSS ---- */


     /* --- Label Styles --- */
     .progress-label {
        font-size: 0.9em;
        white-space: nowrap;
        min-width: 3ch;
        text-align: left;
        font-weight: bold;
        line-height: 1;
        background: var(--labelGradient);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        color: var(--labelColor); /* Fallback */
     }

  </style>
</head>
<body>
  <!-- HTML Structure (Unchanged) -->
  <div class="wrapper">
    <div class="progress-container" id="progress-container">
        <progress id="progress" value="0" max="100"></progress>
        <div id="progress-fill-animated" class="progress-fill-animated"></div>
    </div>
    <div class="progress-label" id="label">0%</div>
  </div>

  <script>
    // --- JAVASCRIPT SECTION ---

    // Helper functions (Unchanged)
    function getQueryParam(name) { const params = new URLSearchParams(window.location.search); return params.get(name); }
    function getRank(progressValue) { if (progressValue === 0) return { rank: "F" }; if (progressValue > 0 && progressValue < 10) return { rank: "E" }; if (progressValue >= 10 && progressValue < 20) return { rank: "D" }; if (progressValue >= 20 && progressValue < 30) return { rank: "D" }; if (progressValue >= 30 && progressValue < 40) return { rank: "C" }; if (progressValue >= 40 && progressValue < 50) return { rank: "C" }; if (progressValue >= 50 && progressValue < 60) return { rank: "B" }; if (progressValue >= 60 && progressValue < 70) return { rank: "B" }; if (progressValue >= 70 && progressValue < 80) return { rank: "A" }; if (progressValue >= 80 && progressValue < 90) return { rank: "A" }; if (progressValue >= 90) return { rank: "S" }; return { rank: "F" }; }
    function parseHsl(hslString) { if (!hslString) { console.warn(`parseHsl received empty input, using grey.`); return { h: 0, s: 0, l: 50 }; } const match = hslString.match(/hsl\(\s*(\d+)\s*,\s*(\d+)%?\s*,\s*(\d+)%?\s*\)/); if (match) { return { h: parseInt(match[1]), s: parseInt(match[2]), l: parseInt(match[3]) }; } console.warn(`Could not parse HSL: ${hslString}, using grey.`); return { h: 0, s: 0, l: 50 }; }
    function interpolateHsl(hsl1, hsl2, factor) { factor = Math.max(0, Math.min(1, factor)); let h1 = hsl1.h; let h2 = hsl2.h; let h; const diff = Math.abs(h1 - h2); if (diff > 180) { if (h1 > h2) { h1 -= 360; } else { h2 -= 360; } } h = (h1 + (h2 - h1) * factor); if (h < 0) { h += 360; } const s = hsl1.s + (hsl2.s - hsl1.s) * factor; const l = hsl1.l + (hsl2.l - hsl1.l) * factor; return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`; }

    // --- initializeBreakpoints (Unchanged) ---
    let colorBreakpoints = [];
    function initializeBreakpoints() { /* ... unchanged ... */
        if (colorBreakpoints.length > 0) return;
        console.log("Initializing breakpoints...");
        const rootStyle = getComputedStyle(document.documentElement);
        const tempData = [];
        const points = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
        try {
            for (const p of points) {
                const startVar = `--color-progress-${p}-start`;
                const endVar = `--color-progress-${p}-end`;
                const startVal = rootStyle.getPropertyValue(startVar)?.trim();
                const endVal = rootStyle.getPropertyValue(endVar)?.trim();
                if (!startVal || !endVal) { console.warn(`Missing or empty CSS variable value for breakpoint ${p}. Var names: ${startVar}, ${endVar}`); }
                tempData.push({ point: p, startColor: parseHsl(startVal), endColor: parseHsl(endVal) });
            }
            colorBreakpoints = tempData;
            console.log("Initialized color breakpoints (built):", colorBreakpoints);
        } catch (e) { console.error("CRITICAL Error during initializeBreakpoints loop.", e); colorBreakpoints = []; }
     }


    // --- getProgressBackgroundStyle (Unchanged) ---
    function getProgressBackgroundStyle(progressValue, progressContainer, urlColor1, urlColor2, isAnimated) { /* ... unchanged ... */
        const computedRootStyle = getComputedStyle(document.documentElement);
        if (progressValue === 0) { return 'var(--color-progress-zero)'; }
        if (progressContainer.classList.contains('rainbow')) {
            if (isAnimated) {
                console.log(`Using ANIMATED rainbow gradient var(--color-rainbow-animated).`);
                return 'var(--color-rainbow-animated)';
            } else {
                console.log(`Using STATIC rainbow gradient var(--color-rainbow-static).`);
                return 'var(--color-rainbow-static)';
            }
        }
        let startColorStr = null; let endColorStr = null; let colorSource = "interpolation";
        const classColorMap = { 'health': { startVar: '--color-health-start', endVar: '--color-health-end' }, 'magic': { startVar: '--color-magic-start', endVar: '--color-magic-end' }, 'physical': { startVar: '--color-physical-start', endVar: '--color-physical-end' }, 'true': { startVar: '--color-true-start', endVar: '--color-true-end' }, 'agility': { startVar: '--color-agility-start', endVar: '--color-agility-end' }, 'intelligence': { startVar: '--color-intelligence-start', endVar: '--color-intelligence-end' }, 'affinity': { startVar: '--color-affinity-start', endVar: '--color-affinity-end' }, };
        for (const cls in classColorMap) {
             if (progressContainer.classList.contains(cls)) {
                 const startVarName = classColorMap[cls].startVar; const endVarName = classColorMap[cls].endVar;
                 const tempStart = computedRootStyle.getPropertyValue(startVarName)?.trim(); const tempEnd = computedRootStyle.getPropertyValue(endVarName)?.trim();
                 if (tempStart && tempEnd) { startColorStr = tempStart; endColorStr = tempEnd; colorSource = `class (${cls})`; console.log(`Using class preset colors: ${startColorStr} -> ${endColorStr}`); break; }
                 else { console.warn(`Missing start/end CSS vars for class ${cls}. Vars: ${startVarName}, ${endVarName}. Falling back.`); }
             }
        }
        if (!startColorStr && urlColor1) {
             startColorStr = urlColor1; endColorStr = urlColor2 ? urlColor2 : urlColor1; colorSource = "url"; console.log(`Using URL param colors: ${startColorStr} -> ${endColorStr}`);
        }
        if (!startColorStr) {
            initializeBreakpoints();
            if (colorBreakpoints.length === 0) { console.error("Breakpoints empty, fallback grey."); startColorStr = '#cccccc'; endColorStr = '#999999'; }
            else {
                 let lowerBound = colorBreakpoints[0]; let upperBound = colorBreakpoints[1];
                 for (let i = 1; i < colorBreakpoints.length; i++) {
                      if (colorBreakpoints[i] && progressValue <= colorBreakpoints[i].point) { if (colorBreakpoints[i - 1]) { lowerBound = colorBreakpoints[i - 1]; } upperBound = colorBreakpoints[i]; break; }
                      if (i === colorBreakpoints.length - 1 && progressValue >= colorBreakpoints[i].point) { lowerBound = upperBound = colorBreakpoints[i]; break; }
                 }
                 if (!lowerBound || !upperBound) { console.error("Bounds error, fallback grey."); startColorStr = '#cccccc'; endColorStr = '#999999'; }
                 else { const segmentRange = upperBound.point - lowerBound.point; const factor = segmentRange === 0 ? 1 : (progressValue - lowerBound.point) / segmentRange; startColorStr = interpolateHsl(lowerBound.startColor, upperBound.startColor, factor); endColorStr = interpolateHsl(lowerBound.endColor, upperBound.endColor, factor); colorSource = "interpolation"; console.log(`Using interpolated colors: ${startColorStr} -> ${endColorStr}`); }
            }
        }
        let gradientString;
        if (isAnimated) { gradientString = `linear-gradient(to right, ${startColorStr}, ${endColorStr}, ${startColorStr}, ${endColorStr})`; console.log(`Generated 4-stop gradient for animation (Source: ${colorSource})`); }
        else { gradientString = `linear-gradient(to right, ${startColorStr}, ${endColorStr})`; console.log(`Generated 2-stop gradient for static display (Source: ${colorSource})`); }
        return gradientString;
    }


    // --- setProgressBar (Unchanged) ---
    function setProgressBar() { /* ... function body unchanged ... */
        // 1. Get Parameters
        initializeBreakpoints();
        const progressValueStr = getQueryParam("progress");
        const urlColor1 = getQueryParam("color1");
        const urlColor2 = getQueryParam("color2");
        const isRanking = getQueryParam("ranking") === 'true';
        const progressClass = getQueryParam("p_class");
        const progressSize = getQueryParam("size");
        const isAnimated = getQueryParam("animate") === 'true';
        const urlSpeed = getQueryParam("speed");
        /* Removed stretch param handling */

        // 2. Get DOM Elements
        const progressContainer = document.getElementById("progress-container");
        const progressElement = document.getElementById("progress");
        const progressFill = document.getElementById("progress-fill-animated");
        const label = document.getElementById("label");
        const rootStyle = document.documentElement.style;

        // 2b. Set Animation Speed Variable
        if (urlSpeed !== null) {
            const speedValue = parseFloat(urlSpeed);
            if (!isNaN(speedValue) && speedValue >= 0) {
                const speedString = `${speedValue}s`;
                rootStyle.setProperty('--animation-speed', speedString);
                console.log(`Animation speed set to: ${speedString}`);
            } else {
                console.warn(`Invalid speed parameter value: "${urlSpeed}". Using default speed.`);
            }
        } else {
             console.log("No speed parameter provided. Using default speed.");
        }
        /* Removed stretch warning */

        // 3. Apply Class and Size
        const potentialClasses = ['health', 'magic', 'physical', 'true', 'agility', 'intelligence', 'affinity', 'rainbow'];
        potentialClasses.forEach(cls => progressContainer.classList.remove(cls));
        if (progressClass && potentialClasses.includes(progressClass)) {
            progressContainer.classList.add(progressClass);
        } else if (progressClass) { console.warn(`Unknown class specified via URL parameter: ${progressClass}`); }
        if (progressSize) { progressContainer.setAttribute('size', progressSize); }
        else { progressContainer.removeAttribute('size'); }

        // 4. Set Progress Value and Fill Width
        const clampedValue = Math.min(Math.max(parseInt(progressValueStr) || 0, 0), 100);
        progressElement.value = clampedValue;
        const fillWidthPercent = (clampedValue / progressElement.max) * 100;
        progressFill.style.width = `${fillWidthPercent}%`;

        // 5. Apply Animation Class to Fill
        // CSS rules handle background-size based on class/animated state
        if (isAnimated) {
            progressFill.classList.add('animated');
            console.log("Animation class 'animated' added to fill element.");
        } else {
            progressFill.classList.remove('animated');
            console.log("Animation class 'animated' removed from fill element.");
        }

        // 6. Calculate Background Style
        const backgroundStyle = getProgressBackgroundStyle(clampedValue, progressContainer, urlColor1, urlColor2, isAnimated);

        // 7. Set Fill Background
        rootStyle.setProperty('--progColor', backgroundStyle);

        // 8. Set Label Text
        let labelText;
        if (isRanking) { const { rank } = getRank(clampedValue); labelText = rank; }
        else { labelText = clampedValue + "%"; }
        label.textContent = labelText;

        // 9. Set Label Style
        // CSS rules handle background-size based on class/animated state
        label.classList.remove("animated-label");
        if (clampedValue === 0) {
            const zeroColor = getComputedStyle(document.documentElement).getPropertyValue('--color-progress-zero').trim();
            rootStyle.setProperty('--labelGradient', 'none');
            rootStyle.setProperty('--labelColor', zeroColor);
            console.log(`Setting label for 0% with solid color: ${zeroColor}`);
        } else {
            rootStyle.setProperty('--labelGradient', backgroundStyle);
            rootStyle.setProperty('--labelColor', 'transparent');
             console.log(`Setting label gradient: ${backgroundStyle}`);
            if (isAnimated) {
                label.classList.add('animated-label');
                console.log("Animation class 'animated-label' added to label text.");
            } else {
                 console.log("Animation class 'animated-label' removed from label text.");
            }
        }
    }

    // --- Initial Setup ---
    try { setProgressBar(); }
    catch (error) { console.error("Error during initial progress bar setup:", error); }

  </script>
</body>
</html>

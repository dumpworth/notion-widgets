<!DOCTYPE html>
<html lang="en" style="margin:0; padding:0; height:30px;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Custom Progress Bar</title>
  <style>
    /* --- Base Variables --- */
    :root {
      /* Colors */
      --color-progress-zero: #666666;
      --color-progress-0-start: hsl(0, 100%, 20%); --color-progress-0-end: hsl(0, 100%, 20%);
      --color-progress-10-start: hsl(0, 100%, 50%); --color-progress-10-end: hsl(10, 100%, 50%);
      --color-progress-20-start: hsl(20, 100%, 50%); --color-progress-20-end: hsl(30, 100%, 50%);
      --color-progress-30-start: hsl(30, 100%, 50%); --color-progress-30-end: hsl(50, 100%, 50%);
      --color-progress-40-start: hsl(40, 100%, 50%); --color-progress-40-end: hsl(60, 100%, 50%);
      --color-progress-50-start: hsl(60, 100%, 50%); --color-progress-50-end: hsl(90, 100%, 50%);
      --color-progress-60-start: hsl(80, 100%, 50%); --color-progress-60-end: hsl(150, 100%, 50%);
      --color-progress-70-start: hsl(100, 100%, 50%); --color-progress-70-end: hsl(160, 100%, 50%);
      --color-progress-80-start: hsl(150, 100%, 50%); --color-progress-80-end: hsl(180, 100%, 50%);
      --color-progress-90-start: hsl(180, 100%, 70%); --color-progress-90-end: hsl(220, 100%, 80%);
      --color-progress-100-start: hsl(220, 100%, 80%); --color-progress-100-end: hsl(320, 100%, 80%);

      /* Class Colors (Start/End) */
      --color-health-start: hsl(150, 100%, 50%); --color-health-end: hsl(180, 100%, 50%);
      --color-magic-start: hsl(220, 100%, 50%); --color-magic-end: hsl(180, 100%, 50%);
      --color-physical-start: hsl(0, 100%, 50%); --color-physical-end: hsl(10, 100%, 70%);
      --color-true-start: hsl(0, 0%, 70%); --color-true-end: hsl(0, 0%, 100%);
      --color-agility-start: hsl(60, 100%, 50%); --color-agility-end: hsl(90, 100%, 50%);
      --color-intelligence-start: cyan; --color-intelligence-end: #ff80ff;
      --color-affinity-start: #ff80ff; --color-affinity-end: #ffb3e7;

      /* Rainbow Gradients */
      --color-rainbow-static: linear-gradient(to right, hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%));
      --color-rainbow-animated: linear-gradient(to right, hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%), hsl(240, 100%, 60%), hsl(300, 100%, 50%), hsl(0, 100%, 55%), hsl(60, 100%, 50%), hsl(120, 100%, 45%), hsl(180, 100%, 50%));

      /* Core Style Variables */
      --progHeight: 10px; --progWidth: 270px; /* Default ideal width */
      --progColor: linear-gradient(to right, #ccc, #999); /* Default fill color */
      --labelGradient: none; /* Default label background */
      --labelColor: var(--color-progress-zero); /* Default label text color */
      --trackBorderColor: rgba(180, 180, 180, 0.6); --trackShadowColor: rgba(0, 0, 0, 0.1);

      /* --- Animation Variables --- */
      --animation-speed: 3s; /* Default gradient shimmer duration */
      --background-width-multiplier: 300%; /* Default multiplier for standard animated gradients */
    }


    /* --- Styles --- */
     body {
       margin: 0;
       /* Default background is transparent, can be overridden by JS */
       background: transparent;
       font-family: sans-serif;
       display: flex;
       align-items: center;
       justify-content: center;
       min-height: 30px;
       padding: 5px;
       overflow-x: hidden;
     }
     .wrapper { display: flex; align-items: center; gap: 10px; padding: 0; width: 100%; max-width: 100%; box-sizing: border-box; }
     .progress-container { position: relative; width: var(--progWidth); height: var(--progHeight); border-radius: var(--progHeight); overflow: hidden; border: 1px solid var(--trackBorderColor); background: transparent; box-shadow: inset 0 1px 2px var(--trackShadowColor); box-sizing: border-box; flex-shrink: 1; min-width: 50px; }
     .progress-container[size="infobox"] { --progWidth: 207px; } .progress-container[size="ability"] { --progWidth: 225px; } .progress-container[size="large"] { --progWidth: 540px; }
     progress { display: block; width: 100%; height: 100%; appearance: none; -webkit-appearance: none; border: none; background: transparent; color: transparent; border-radius: 0; }
     progress::-webkit-progress-bar { background: transparent; } progress::-webkit-progress-value { background: transparent; } progress::-moz-progress-bar { background: transparent; }
     .progress-fill-animated { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--progColor); border-radius: 0; /* No transition */ }
     @keyframes moveGradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
     .progress-fill-animated.animated, .progress-label.animated-label { animation: moveGradient var(--animation-speed) linear infinite; }
     .progress-fill-animated.animated, .progress-label.animated-label { background-size: var(--background-width-multiplier) 100%; }
     .progress-container.rainbow .progress-fill-animated.animated { background-size: 200% 100%; }
     .progress-container.rainbow + .progress-label.animated-label { background-size: 200% 100%; }
     .progress-label { font-size: 0.9em; white-space: nowrap; min-width: 3ch; text-align: left; font-weight: bold; line-height: 1; background: var(--labelGradient); -webkit-background-clip: text; background-clip: text; color: transparent; color: var(--labelColor); flex-shrink: 0; }
  </style>
</head>
<body style="margin:0; padding:0; height:30px;">
  <!-- HTML Structure -->
  <div class="wrapper">
    <div class="progress-container" id="progress-container">
        <progress id="progress" value="0" max="100"></progress>
        <div id="progress-fill-animated" class="progress-fill-animated"></div>
    </div>
    <div class="progress-label" id="label">0%</div>
  </div>

  <script>
    // --- JAVASCRIPT SECTION ---

    // Helper functions (Unchanged)
    function getQueryParam(name) { const params = new URLSearchParams(window.location.search); return params.get(name); }
    function getRank(progressValue) { if (progressValue === 0) return { rank: "F" }; if (progressValue > 0 && progressValue < 10) return { rank: "E" }; if (progressValue >= 10 && progressValue < 20) return { rank: "D" }; if (progressValue >= 20 && progressValue < 30) return { rank: "D" }; if (progressValue >= 30 && progressValue < 40) return { rank: "C" }; if (progressValue >= 40 && progressValue < 50) return { rank: "C" }; if (progressValue >= 50 && progressValue < 60) return { rank: "B" }; if (progressValue >= 60 && progressValue < 70) return { rank: "B" }; if (progressValue >= 70 && progressValue < 80) return { rank: "A" }; if (progressValue >= 80 && progressValue < 90) return { rank: "A" }; if (progressValue >= 90) return { rank: "S" }; return { rank: "F" }; }
    function parseHsl(hslString) { if (!hslString) { console.warn(`parseHsl received empty input, using grey.`); return { h: 0, s: 0, l: 50 }; } const match = hslString.match(/hsl\(\s*(\d+)\s*,\s*(\d+)%?\s*,\s*(\d+)%?\s*\)/); if (match) { return { h: parseInt(match[1]), s: parseInt(match[2]), l: parseInt(match[3]) }; } console.warn(`Could not parse HSL: ${hslString}, using grey.`); return { h: 0, s: 0, l: 50 }; }
    function interpolateHsl(hsl1, hsl2, factor) { factor = Math.max(0, Math.min(1, factor)); let h1 = hsl1.h; let h2 = hsl2.h; let h; const diff = Math.abs(h1 - h2); if (diff > 180) { if (h1 > h2) { h1 -= 360; } else { h2 -= 360; } } h = (h1 + (h2 - h1) * factor); if (h < 0) { h += 360; } const s = hsl1.s + (hsl2.s - hsl1.s) * factor; const l = hsl1.l + (hsl2.l - hsl1.l) * factor; return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`; }

    // --- initializeBreakpoints (Unchanged) ---
    let colorBreakpoints = [];
    function initializeBreakpoints() { /* ... same code ... */
        if (colorBreakpoints.length > 0) return;
        const rootStyle = getComputedStyle(document.documentElement);
        const tempData = [];
        const points = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
        try {
            for (const p of points) {
                const startVar = `--color-progress-${p}-start`;
                const endVar = `--color-progress-${p}-end`;
                const startVal = rootStyle.getPropertyValue(startVar)?.trim();
                const endVal = rootStyle.getPropertyValue(endVar)?.trim();
                if (!startVal) { console.warn(`Missing or empty CSS variable value for ${startVar}`); }
                if (!endVal) { console.warn(`Missing or empty CSS variable value for ${endVar}`); }
                tempData.push({ point: p, startColor: parseHsl(startVal), endColor: parseHsl(endVal) });
            }
            colorBreakpoints = tempData;
        } catch (e) { console.error("CRITICAL Error during initializeBreakpoints loop.", e); colorBreakpoints = []; }
    }

    // --- getProgressBackgroundStyle (Unchanged) ---
    // Returns { style: string, endColor: string, isGradient: boolean }
    function getProgressBackgroundStyle(progressValue, progressContainer, urlColor1, urlColor2, isAnimated) { /* ... same code ... */
        const computedRootStyle = getComputedStyle(document.documentElement); const defaultGrey = '#cccccc'; const zeroColor = computedRootStyle.getPropertyValue('--color-progress-zero').trim() || '#666666'; if (progressValue === 0) { return { style: zeroColor, endColor: zeroColor, isGradient: false }; } let startColorStr = null; let endColorStr = null; let isGradient = true; if (progressContainer.classList.contains('rainbow')) { const style = isAnimated ? 'var(--color-rainbow-animated)' : 'var(--color-rainbow-static)'; const fallbackEndColor = 'hsl(180, 100%, 50%)'; return { style: style, endColor: fallbackEndColor, isGradient: true }; } const classColorMap = { 'health': { startVar: '--color-health-start', endVar: '--color-health-end' }, 'magic': { startVar: '--color-magic-start', endVar: '--color-magic-end' }, 'physical': { startVar: '--color-physical-start', endVar: '--color-physical-end' }, 'true': { startVar: '--color-true-start', endVar: '--color-true-end' }, 'agility': { startVar: '--color-agility-start', endVar: '--color-agility-end' }, 'intelligence': { startVar: '--color-intelligence-start', endVar: '--color-intelligence-end' }, 'affinity': { startVar: '--color-affinity-start', endVar: '--color-affinity-end' } }; for (const cls in classColorMap) { if (progressContainer.classList.contains(cls)) { const startVarName = classColorMap[cls].startVar; const endVarName = classColorMap[cls].endVar; const tempStart = computedRootStyle.getPropertyValue(startVarName)?.trim(); const tempEnd = computedRootStyle.getPropertyValue(endVarName)?.trim(); if (tempStart && tempEnd) { startColorStr = tempStart; endColorStr = tempEnd; break; } else { console.warn(`Missing start/end CSS vars for class ${cls}.`); } } } if (!startColorStr && urlColor1) { startColorStr = urlColor1; endColorStr = urlColor2 ? urlColor2 : urlColor1; } if (!startColorStr) { initializeBreakpoints(); if (colorBreakpoints.length > 0) { let lowerBound = colorBreakpoints[0], upperBound = colorBreakpoints[1]; for (let i = 1; i < colorBreakpoints.length; i++) { if (colorBreakpoints[i] && progressValue <= colorBreakpoints[i].point) { if (colorBreakpoints[i - 1]) lowerBound = colorBreakpoints[i - 1]; upperBound = colorBreakpoints[i]; break; } if (i === colorBreakpoints.length - 1 && progressValue >= colorBreakpoints[i].point) { lowerBound = upperBound = colorBreakpoints[i]; break; } } if (lowerBound && upperBound) { const segmentRange = upperBound.point - lowerBound.point; const factor = segmentRange === 0 ? 1 : (progressValue - lowerBound.point) / segmentRange; startColorStr = interpolateHsl(lowerBound.startColor, upperBound.startColor, factor); endColorStr = interpolateHsl(lowerBound.endColor, upperBound.endColor, factor); } } if (!startColorStr) { startColorStr = defaultGrey; endColorStr = '#999999'; } } let finalStyle; let finalEndColor = endColorStr || startColorStr || defaultGrey; if (startColorStr && endColorStr && startColorStr === endColorStr) { finalStyle = startColorStr; isGradient = false; finalEndColor = startColorStr; } else { isGradient = true; if (isAnimated) { finalStyle = `linear-gradient(to right, ${startColorStr}, ${endColorStr}, ${startColorStr}, ${endColorStr})`; } else { finalStyle = `linear-gradient(to right, ${startColorStr}, ${endColorStr})`; } } return { style: finalStyle, endColor: finalEndColor, isGradient: isGradient };
    }

    // --- Helper: Update All Visuals based on Value (Unchanged) ---
    function updateVisuals(value, progressElement, progressFill, label, isRanking, isAnimated, progressContainer, urlColor1, urlColor2) { /* ... same code ... */
        const clampedValue = Math.min(Math.max(Math.round(value), 0), 100); const isRainbow = progressContainer.classList.contains('rainbow'); progressElement.value = clampedValue; const fillWidthPercent = (clampedValue / progressElement.max) * 100; progressFill.style.width = `${fillWidthPercent}%`; let labelText; if (isRanking) { labelText = getRank(clampedValue).rank; } else { labelText = clampedValue + "%"; } label.textContent = labelText; const styleInfo = getProgressBackgroundStyle(clampedValue, progressContainer, urlColor1, urlColor2, isAnimated); const rootStyle = document.documentElement.style; rootStyle.setProperty('--progColor', styleInfo.style); label.classList.remove('animated-label'); if (clampedValue === 0) { const zeroColor = getComputedStyle(document.documentElement).getPropertyValue('--color-progress-zero').trim() || '#666666'; rootStyle.setProperty('--labelGradient', 'none'); rootStyle.setProperty('--labelColor', zeroColor); } else if (isAnimated) { rootStyle.setProperty('--labelGradient', styleInfo.style); rootStyle.setProperty('--labelColor', 'transparent'); label.classList.add('animated-label'); } else { if (isRainbow) { rootStyle.setProperty('--labelGradient', 'var(--color-rainbow-static)'); rootStyle.setProperty('--labelColor', 'transparent'); } else { rootStyle.setProperty('--labelGradient', 'none'); rootStyle.setProperty('--labelColor', styleInfo.endColor); } }
    }


    // --- Setup Function (Handles both Static and Loop Test) ---
    function setupProgressBar() {
        // 1. Get Parameters
        const progressValueStr = getQueryParam("progress");
        const urlColor1 = getQueryParam("color1");
        const urlColor2 = getQueryParam("color2");
        const isRanking = getQueryParam("ranking") === 'true';
        const progressClass = getQueryParam("p_class");
        const progressSize = getQueryParam("size");
        const isAnimated = getQueryParam("animate") === 'true'; // For shimmer
        const urlSpeed = getQueryParam("speed"); // Shimmer speed
        const isLoopTesting = getQueryParam("looptest") === 'true';
        const urlLoopDuration = getQueryParam("loopDuration"); // Loop duration
        const bgColorParam = getQueryParam("bgcolor"); // <-- NEW: Background color param

        // 2. Get DOM Elements
        const progressContainer = document.getElementById("progress-container");
        const progressElement = document.getElementById("progress");
        const progressFill = document.getElementById("progress-fill-animated");
        const label = document.getElementById("label");

        if (!progressContainer || !progressElement || !progressFill || !label) { console.error("Initialization failed: Could not find essential elements."); return; }

        // --- NEW: Set Body Background Color ---
        if (bgColorParam) {
            // Directly apply the value from the URL parameter to the body's background
            // CSS color values are generally forgiving (e.g., "red", "#f00", "rgba(255,0,0,0.5)")
            console.log(`Setting body background color to: ${bgColorParam}`);
            document.body.style.backgroundColor = bgColorParam;
        } else {
            // If no parameter, the CSS default 'background: transparent;' will apply
            console.log("No bgcolor parameter found, using default body background.");
        }
        // --- End NEW ---


        // 3. Apply Class, Size, and Shimmer Speed (Common setup)
        const potentialClasses = ['health', 'magic', 'physical', 'true', 'agility', 'intelligence', 'affinity', 'rainbow'];
        potentialClasses.forEach(cls => progressContainer.classList.remove(cls));
        if (progressClass && potentialClasses.includes(progressClass)) { progressContainer.classList.add(progressClass); } else if (progressClass) { console.warn(`Unknown class specified: ${progressClass}`); }
        if (progressSize) { progressContainer.setAttribute('size', progressSize); } else { progressContainer.removeAttribute('size'); }
        if (urlSpeed !== null) { const speedValue = parseFloat(urlSpeed); if (!isNaN(speedValue) && speedValue >= 0) { document.documentElement.style.setProperty('--animation-speed', `${speedValue}s`); } else { console.warn(`Invalid speed: "${urlSpeed}". Using default.`); } }
        progressFill.classList.toggle('animated', isAnimated);


        // --- Branch Logic ---
        if (isLoopTesting) { // Loop Test Mode
            console.log("Loop Test Mode Enabled.");
            let loopDurationMs = 10000; // Default duration
            if (urlLoopDuration !== null) { const requestedDuration = parseInt(urlLoopDuration); if (!isNaN(requestedDuration) && requestedDuration >= 100) { loopDurationMs = requestedDuration; console.log(`Loop test duration set to: ${loopDurationMs}ms`); } else { console.warn(`Invalid loopDuration: "${urlLoopDuration}". Using default ${loopDurationMs}ms.`); } } else { console.log(`Using default loop test duration: ${loopDurationMs}ms`); }

            let startTime = null; let animationRequestId = null; const cycleDuration = loopDurationMs;

            function animateLoop(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime; const timeInCycle = elapsed % cycleDuration; const halfCycle = cycleDuration / 2; let currentValue;
                if (timeInCycle < halfCycle) { currentValue = (timeInCycle / halfCycle) * 100; } else { currentValue = (1 - (timeInCycle - halfCycle) / halfCycle) * 100; }
                updateVisuals(currentValue, progressElement, progressFill, label, isRanking, isAnimated, progressContainer, urlColor1, urlColor2);
                animationRequestId = requestAnimationFrame(animateLoop);
            }
            updateVisuals(0, progressElement, progressFill, label, isRanking, isAnimated, progressContainer, urlColor1, urlColor2);
            animationRequestId = requestAnimationFrame(animateLoop);

        } else { // Static Mode
            console.log("Static Mode.");
            const staticValue = parseInt(progressValueStr) || 0;
            updateVisuals(staticValue, progressElement, progressFill, label, isRanking, isAnimated, progressContainer, urlColor1, urlColor2);
        }
    }

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', (event) => {
        console.log("DOM ready. Setting up progress bar.");
        try { setupProgressBar(); } catch (error) { console.error("Error during progress bar setup:", error); }
    });

  </script>
</body>
</html>
